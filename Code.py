# -*- coding: utf-8 -*-
"""lab6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pLaN8ZH2PZqP-vQ1Bjasc4IRkpSozrhK
"""

import json
import ast
import pickle
from collections import namedtuple
from json import JSONEncoder
from types import SimpleNamespace

directory_structure = {'root':{}}
a_file = open("sample.dat", "wb")
pickle.dump(directory_structure, a_file)
a_file.close()

a_file = open("sample.dat", "rb")
output = pickle.load(a_file)

#CLASS FOR FILE 
class File:
    def __init__(self,Name,Data,Identifier,Type,Location,Size):
        self.Name = Name
        self.Data = Data
        self.Identifier = Identifier
        self.Type = Type
        self.Location = Location
        self.Size = Size
        
    def to_json(self):
        '''
        convert the instance of this class to json
        '''
        return json.dumps(self, indent = 4, default=lambda o: o.__dict__)
        
    
    def write(self, text):
        self.Data = self.Data + text
    
    #writes to a specific point in the file
    def write_to(self,write_at,text):
        self.Data = self.Data[:write_at] + text + self.Data[write_at+1:]
        
    #read all the data from start to end
    def read(self):
        print("File Content:")
        print(self.Data)

    #read from a specific point in the file
    def read_from(self,start,size):
        print("File Content:")
        print(self.Data[start:size])
    
    #reduce the size of the file to given size
    def truncate_file(self,maxSize):
        self.Data = self.Data[:maxSize]
        
    #move content within file
    def move_within_file(self,start,size,target):
        end = start + size
        tempData = self.Data[start:end]
        self.Data = self.Data[:target] + tempData + self.Data[target:]
        if(self.Data[start:end]==tempData):       
            charArr = list(self.Data)
            charArr[start:end] =""
            self.Data = "".join(charArr)
        else:            
            start = start + size
            end = end + size
            charArr = list(self.Data)
            charArr[start:end] =""
            self.Data = "".join(charArr)

########## FUNCTIONS #########
 
# Iniatilizing DIRECTORY    
directory_structure = output

#Starting the program from root directory
current_directory=directory_structure["root"]
prev_directory=directory_structure["root"]

#DELETE FILE CODE
def deleteFile(filePath,directory_structure):

    #checking if the filePath given is empty
    if(filePath==''):
        print("The path given is invalid !")
        return directory_structure #return the directory_structure without any changes
    
    #storing all directories in list 
    directories=filePath.split("/")
    
    if(len(directories)==1):
        if(directories[0] in directory_structure):
            del directory_structure[directories[0]]
            print("The given file/folder is successfully deleted !")
        else:
            print("The given file/folder is not present in the directory")
            
    else:
        name=directories[len(directories)-1] #taking last element in directory as the file/folder to delete
    directories.pop()
    
    traverse_success=False
    old_directory=directory_structure
    for directory in directories:
        if(directory in old_directory):
            current_directory=old_directory[directory]
            old_directory=current_directory
            traverse_success=True
            
        else:
            print("The path given is invalid !")
            traverse_success=False
            break
         
    # seeing if the path to directory where we have to delete file/folder exists  
    if(traverse_success):
        #if the file/folder to delete exists in the given directory
        if (name in current_directory):
            del current_directory[name]
            print("The given file/folder is successfully deleted !")
        else:
            print("The given file/folder is not present in the directory")  
    
         
    return directory_structure #return the directory_structure after performing deleting operations

# DIRECTORY TRAVERSAL CODE
def traverse(directory_structure,directory):
    
    if(directory==".."):
        if("prev" in directory_structure):
            current_directory=directory_structure['prev']
            return current_directory
        else:
            print("You are in root directory ! Can't go back !")
            return directory_structure
                    
        
    else:
        if(directory in directory_structure):
            prev_directory=directory_structure
            current_directory=directory_structure[directory] # moving to the next directory
            current_directory["prev"]=prev_directory
            print("Moved to the desired path")
            return current_directory
        else:
            print("the path does not exist")
            return "Null"

#CREATE FILE CODE
def createFile(name,type_of_file,data,current_directory):
    file_obj=File(name,data,"abc_id",type_of_file,current_directory,str(len(data))+" bits")
    name = name + '.' + type_of_file
    if(name in current_directory):
        print("File already exists with the same name")
    else:
        #print(file_obj.to_json())
        current_directory[name]=file_obj.to_json()
        print("File created successfully")
        return current_directory

#CREATE DIR CODE
def createDIR(name,current_directory):
    
    if(name in current_directory):
        print("Directory already exists with the same name")
    else:
        current_directory[name]={}
        print("Directory created successfully")
        return current_directory

#OPEN FILE CODE
def openFile(name,mode,current_directory):
    y = json.loads(current_directory[name], object_hook=lambda d: SimpleNamespace(**d))
    x=File(y.Name,y.Data,"abc_id",y.Type,"unknown",str(len(y.Data))+" bits")
    print(x)
    
    if(mode=="r"):
        x.read()
        print("File Read successfully")

    elif(mode=="rf"):
        position=input("Enter the index where you want to read from :")
        size=input("Enter the index to read till: ")
        x.read_from(int(position),int(size))
        print("File Read successfully")        
        
    elif(mode=="w"):
        content=input("Enter the content you want to write in file: ")
        x.write(content)
        print("File Write successfully")
        
    elif(mode=="wa"):
        content=input("Enter the content you want to write in file: ")
        position=input("Enter the index where you want to write at: ")
        x.write_to(int(position),content)
        print("File Write successfully")
        
        
    elif(mode=="t"):
        index=int(input("Enter the index to keep the data till that index: "))
        x.truncate_file(index)
        print("File Truncated successfully")
        
    elif(mode=="mv_in"):
        move_start_index=input("Enter the index to move data from: ")
        move_size=input("Enter the size to read till inside file from move_start position: ")
        move_target_index=input("Enter the target index to move at? (Only integer value): ")
        x.move_within_file(int(move_start_index),int(move_size),int(move_target_index))
        print("Data Move Succesfull")
        
    else:
        print("The mode does not exist")

#MOVE DIRECTORY CODE
def moveDirectory(sourcePath,targetPath,directory_structure):

    #checking if the filePath given is empty
    if(sourcePath=='' or targetPath==''):
        print("The path given is invalid !")
        return directory_structure #return the directory_structure without any changes
    
    source_directories=sourcePath.split("/")
    
    target_directories=targetPath.split("/")
    
    if(len(source_directories)==1):
        print("Cannot move the root directory")
        return directory_structure #return the directory_structure without any changes
            
    else:
        moving_directory=source_directories[len(source_directories)-1] #taking last element in source directory as the file/folder to move
        
    source_directories.pop()    
#     moving_directory=source_directories.pop() #removing the file from source directory
    print(f"MOVING DIRECTORY NAME:  {moving_directory}")
    
#     Traversing to move to source directory to fetch file name and content
    traverse_success=False
    old_directory=directory_structure
    for directory in source_directories:
        if(directory in old_directory):
            current_directory=old_directory[directory]
            old_directory=current_directory
            traverse_success=True
            
        else:
            print("The target path given is invalid !")
            traverse_success=False
            break
   
    #saving directory to be moved in temporary place to remove it from its source directory once
    #it has been moved
    temp_directory=old_directory 
    
    if(traverse_success):
        moving_content=current_directory[moving_directory]
        print(f"MOVING DIRECTORY CONTENT:  {moving_content}/n MOVING DIRECTORY NAME:  {moving_directory}")
    else:
         return directory_structure #return the directory_structure after performing deleting operations
        
        
    
    
#     Traversing to move to target directory to place the source file into target file
    traverse_success=False
    old_directory=directory_structure
    for directory in target_directories:
        if(directory in old_directory):
            current_directory=old_directory[directory]
            old_directory=current_directory
            traverse_success=True
            
        else:
            print("The source path given is invalid !")
            traverse_success=False
            break
         
    # seeing if the path to directory where we have to move file/folder exists  
    if(traverse_success):
        current_directory[moving_directory]=moving_content
        
        if (target_directories[len(target_directories)-1]==source_directories[len(source_directories)-1]):
            print(f"Moving the file to the same path")
            
        else:
            print("The given file/folder is successfully moved !")
            del temp_directory[moving_directory]
         
    
    return directory_structure #return the directory_structure after performing deleting operations

#Traversal Code Implementation
def chDir(current_directory):
    userCD = input("Enter your desired directory:")
    traversal=traverse(current_directory,userCD)
    if(traversal!="Null"):  
        current_directory=traversal
        print(f"Current_directory: {current_directory}")
    return current_directory

# FILE CREATION CODE Implementation
def touch(current_directory):
    fileName = input("Enter File Name:")
    fileExtension = input("Enter file extension:")
    fileData = input("Enter file content:")  
    createFile(fileName,fileExtension,fileData,current_directory)

#TEST CODE FOR DIRECTORY/FILE DELETION
def delFile(directory_structure):
    path = input("Enter absolute path to the file to be deleted:")     
    result=deleteFile(path,directory_structure)
    print(f"dictionary after deletion:\n {result}")

#DIR CREATION CODE Implementation
def mkdir(current_directory):
    dirName = input("Enter Directory Name:")
    createDIR(dirName, current_directory)

#MOVE DIRECTORY CODE
def move(directory_structure):
    sourcePath = input("Enter path to the source file:")
    targetPath = input("Enter target path:")
    result = moveDirectory(sourcePath, targetPath, directory_structure)
    #print(f"{result}")

#OPEN FILE CODE
def openF(current_directory):
    fileName = input("Enter File name: ")
    mode = input("Enter File Mode ['r','w','rf','wa','t','mv_in']: ")
    openFile(fileName, mode, current_directory)

#LIST ALL ITEMS IN CURRENT DIRECTORY
def listAll(current_directory):
    keys = list(current_directory.keys())
    print("Root Directory Distribution: ", keys)


#Driver Code
def driver(choice,current_directory,directory_structure):
    if (choice == 1):
        touch(current_directory)
    elif (choice == 2):
        delFile(directory_structure)
    elif (choice == 3):
        mkdir(current_directory)
    elif (choice == 4):
            listOfGlobals = globals()
            listOfGlobals['current_directory'] = chDir(current_directory)
    elif (choice == 5):
        move(current_directory)
    elif (choice == 6):
        openF(current_directory)
    elif (choice == 7):
        listAll(current_directory)

print("*******WELCOME TO FILE MANAGEMENT SYSTEM*********")
while(True):
    print("\nMENU:")
    print("1)Create File\n2)Delete File\n3)Create Directory\n4)Change Directory\n5)Move File\n6)Open File\n7)Display Memory Map\n8)Exit")
    choice = int(input("Please select an option: "))
    if (choice < 1 or choice > 8):
        print("Please enter a valid option!!!")
    elif (choice == 8):
        print("----------------PROGRAM ENDED----------------")
        break
    else:
        driver(choice, current_directory, directory_structure)
    


a_file = open("sample.dat", "wb")
pickle.dump(directory_structure, a_file)
a_file.close()
